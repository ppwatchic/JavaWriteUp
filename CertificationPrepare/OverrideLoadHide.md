## Final method in a super class
Note: A final method in a super class can not be hiden, override from a subclass.   
There will be a compilation error if do so as shown in the code snippet:   
```
class Super {
  public final int getNext(int i) {
    return i++;
  }
}

class Sub extends Super {
  public int getNext(int i) { // Error, can only fix by remove final from Super class
    return i++;
  }
}
```  

## Method Signature
> Note: Definition: Two of the components of a method declaration comprise the method signatureâ€”the **method's name** and the **parameter types**.

## Final in method parameters
A `final` modifier on a method parameter is not mentioned in the rules for matching signatures of overridden methods, and it has **no effect** on the caller, only within the body of an implementation. Alsothe final modifier on a method parameter has no effect on the generated byte code. (This is not true for other uses of final.)

## [Overload, widen, and autoboxing](http://stackoverflow.com/questions/12879910/varargs-in-method-overloading-in-java)  
You can either `Widen` or `Box` but you cannot do both, unless you are boxing and widening to Object (An int to Integer(Boxing) and then Integer to Object(Widening) is legal, since every class is a subclass of Object, so it is possible for Integer to be passed to Object parameter)

Similarly an `int` to `Number` is also legal (`int -> Integer -> Number`) Since Number is the super class of Integer it is possible.

in this example:  
```
public static void test(Integer...i)
public static void test(Float...f)
```  
There are some rules that are followed when selecting which overloaded method to select, when Boxing, Widening, and Var-args are combined:  
* primitive widening uses the smallest method argument possible
* Wrapper type cannot be widened to another Wrapper type
* You can Box from int to Integer and widen to Object but no to Long
* Widening beats Boxing, Boxing beats Var-args.
* You can Box and then Widen (An int can become Object via Integer)
* You cannot Widen and then Box (An int cannot become Long)
* You cannot combine var-args, with either widening or boxing
So, based on the above given rules  
When you pass two integers to above functions,  

according to rule 3, it will have to be first Widened and then Boxed to fit into a Long, which is illegal according to rule 5 (You cannot Widen and then Box).
So, it is Boxed to store in Integer var-args.
But in first case, where you have methods with var-args of primitive types: -

public static void test(int...i)
public static void test(float...f)
Then test(1, 2) can invoke both the methods (Since neither of them is more suitable for rule 1 to apply) : -

In first case it will be var-args
In second case, it will be Widening and then Var-args (which is allowed)
Now, when you have methods with exactly one int and one flost: -

public static void test(int i)
public static void test(float f)
Then on invoking using test(1), rule 1 is followed, and smallest possible widening (i.e. the int where no widening is needed at all) is chosen. So 1st method will be invoked.
